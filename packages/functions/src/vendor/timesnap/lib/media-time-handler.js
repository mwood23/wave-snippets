/**
 * BSD 3-Clause License
 *
 * Copyright (c) 2018-2020, Steve Tung
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of the copyright holder nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

const initializeMediaTimeHandler = function (page) {
  return page.evaluateOnNewDocument(function () {
    (function () {
      const timesnapEventDetail = 'timesnap generated';
      var mediaList = [];
      var currentTimePropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype, 'currentTime');
      var addMediaNode = function (node) {
        if (node._timesnap_customized) { // this function has already been called
          return;
        }
        node._timesnap_customized = true;
        var lastUpdated = window.Date.now();
        var precisionTime = node.currentTime * 1000;
        var pendingSeeked;
        var autoplay = node.autoplay;
        var paused = !node.autoplay && node.paused;
        var ended = node.ended;
        node._timesnap_oldPlay = node.play;
        node._timesnap_oldPause = node.pause;
        var media = {
          node: node,
          goToTime: function () {
            var elapsedTime = window.Date.now() - lastUpdated;
            var p;
            var playbackRate;
            if (!paused) {
              if (precisionTime / 1000 < node.duration || node.loop) {
                ended = false;
              }
              if (!ended) {
                playbackRate = node.playbackRate;
                precisionTime = precisionTime + (elapsedTime * playbackRate);
                if (node.duration && precisionTime / 1000 > node.duration) {
                  if (node.loop) {
                    precisionTime -= node.duration * 1000;
                  } else {
                    precisionTime = node.duration * 1000;
                    ended = true;
                    node.dispatchEvent(new CustomEvent('ended', { detail: timesnapEventDetail }));
                  }
                }
                if (playbackRate < 0 && node.duration && precisionTime < 0) {
                  // negative playbackRate is not currently supported in Chromium/Chrome,
                  // but this is here if it does in the future
                  if (node.loop) {
                    precisionTime += node.duration * 1000;
                  } else {
                    precisionTime = 0;
                    // should 'ended' be fired here?
                  }
                }
                p = new Promise(function (resolve) {
                  pendingSeeked = resolve;
                });
                node._timesnap_oldCurrentTime = precisionTime / 1000;
              }
            }
            lastUpdated = window.Date.now();
            return p;
          }
        };
        node.addEventListener('seeked', function () {
          if (pendingSeeked) {
            pendingSeeked();
            pendingSeeked = null;
          } else {
            // possibly generated by user or by another program
            lastUpdated = window.Date.now();
            precisionTime = node._timesnap_oldCurrentTime * 1000;
          }
        });
        mediaList.push(media);
        node._timesnap_oldPause();
        Object.defineProperty(node, '_timesnap_oldCurrentTime', currentTimePropertyDescriptor);
        Object.defineProperty(node, 'currentTime', {
          get: function () {
            return node._timesnap_oldCurrentTime;
          },
          set: function (time) {
            lastUpdated = window.Date.now();
            precisionTime = time * 1000;
            node._timesnap_oldCurrentTime = time;
          }
        });
        Object.defineProperty(node, 'autoplay', {
          get: function () {
            return autoplay;
          },
          set: function (shouldAutoplay) {
            autoplay = shouldAutoplay;
            if (autoplay && paused) {
              lastUpdated = window.Date.now();
              paused = false;
              node.dispatchEvent(new CustomEvent('play', { detail: timesnapEventDetail }));
            }
          }
        });
        Object.defineProperty(node, 'paused', {
          get: function () {
            return paused;
          }
        });
        Object.defineProperty(node, 'ended', {
          get: function () {
            return ended;
          }
        });
        node.play = function () {
          lastUpdated = window.Date.now();
          paused = false;
          node.dispatchEvent(new CustomEvent('play', { detail: timesnapEventDetail }));
        };
        node.pause = function () {
          media.goToTime(window.Date.now());
          paused = true;
          node.dispatchEvent(new CustomEvent('pause', { detail: timesnapEventDetail }));
        };
        node.addEventListener('play', function (e) {
          if (e.isTrusted) {
            media.goToTime();
            paused = false;
            node._timesnap_oldPause();
          } else if (e.detail !== timesnapEventDetail) {
            e.stopImmediatePropagation();
          }
        });
        node.addEventListener('pause', function (e) {
          // e.isTrusted checks whether the event is user generated
          if (e.isTrusted) {
            media.goToTime();
            paused = true;
          } else if (e.detail !== timesnapEventDetail) {
            e.stopImmediatePropagation();
          }
        });
        if (!paused && !ended) {
          // a 'pause' event may have been unintentionally dispatched
          // before with `node._timesnap_oldPause()`
          // now we'll dispatch a `play` event
          node.dispatchEvent(new CustomEvent('play', { detail: timesnapEventDetail }));
        }
      };

      var removeMediaNode = function (node) {
        mediaList = mediaList.filter(function (media) {
          return media.node !== node;
        });
      };

      // When identifying media nodes, using a MutationObserver covers
      // most use cases, since it directly observes the DOM
      // The cases it doesn't cover is when elements are not added to DOM
      // or significant operations occur on the elements before they are added,
      // in which order matters (e.g. `addEventListener`).
      // For many of those remaining cases, we'll also overwrite
      // document.createElement and document.createElementNS
      // There still remains cases where elements are created via other means
      // (e.g. through `div.innerHTML`), and then operations are done on them
      // before adding them to DOM

      // mediaObserver covers elements when they're added to DOM
      var mediaObserver = new MutationObserver(function (mutationsList) {
        for (let mutation of mutationsList) {
          if (mutation.type === 'childList') {
            for (let node of mutation.addedNodes) {
              if (node.nodeName === 'VIDEO') {
                addMediaNode(node);
              }
            }
            for (let node of mutation.removedNodes) {
              if (node.nodeName === 'VIDEO') {
                removeMediaNode(node);
              }
            }
          }
        }
      });

      mediaObserver.observe(document, {
        attributes: false,
        childList: true,
        characterData: false,
        subtree: true
      });

      // Ovewriting createElement and createElementNS covers
      // most cases where elements are created programatically.
      // mediaObserver will eventually cover them,
      // but before then event listeners may be added,
      // before e.stopImmediatePropagation can be called
      var oldCreateElement = document.createElement;
      document.createElement = function createElement(tagName, options) {
        var element = oldCreateElement.call(document, tagName, options);
        if (tagName.toLowerCase() === 'video') {
          addMediaNode(element);
        }
        return element;
      };

      var oldCreateElementNS = document.createElementNS;
      document.createElementNS = function createElementNS(ns, qualifiedName, options) {
        var element = oldCreateElementNS.call(document, ns, qualifiedName, options);
        var type = qualifiedName.toLowerCase();
        if (type === 'video' || type.endsWith(':video')) {
          addMediaNode(element);
        }
        return element;
      };

      window._timesnap_addFramePreparer({
        shouldRun: function () {
          return mediaList.length && mediaList.reduce(function (a, b) {
            return a || (!b.paused && !b.ended);
          }, false);
        },
        prepare: function (time) {
          return Promise.all(mediaList.map(media => media.goToTime(time)));
        }
      });
    })();
  });
};

module.exports = initializeMediaTimeHandler;